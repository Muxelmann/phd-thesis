\section{Control of BESS}
\label{ch2:sec:control-of-bess}

\input{_chapter2/fig/system-controller}

This section explains the dynamic control (i.e. the controller block that is shown in Figure \ref{ch2:subfig:proposed-dynamic-control-system}), which contains the two PID compensators.
The first PID compensator is fed by the BESS schedule, and the other is fed by the MPC load estimations.
After the control system is detailed in this section, the auto-regressive models, which were used during the course of this research, are explained, too.

\subsection{Dynamic control}

The content of the dynamic control procedure is shown in Figure \ref{ch2:fig:system-controller}.
Here, two reference signals are used as inputs to the dynamic control.
The first reference signal is the SOC profile derived from the BESS scheduled, $SOC(t)$, and the second is an estimated future network power, $\hat{p}(t+\Delta t)$.
These two inputs are fed into compensator PID$_1$ and compensator PID$_2$, respectively.
The output of each compensator is a corrective battery power component that, when summed, yields the next BESS power, i.e. $p(t+\Delta t)$, which is applied to the BESS model.
Each PID compensator also receives a feedback signal to compute the internal error states.
More specifically, PID$_1$ receives the most recent SOC value that is obtained from the BESS model, $SOC^*(t)$, and PID$_2$ receives the network's most recent power demand, $p_{net}(t)$ (e.g. through measurements by substation monitoring).

\nomenclature{$p_{net}(t)$}{Most recent network demand at sample $t$, where $p_{net}(t) \in \textbf{p}_{net}$}
\nomenclature{$SOC^*(t)$}{Battery's state of charge at sample $t$}
\nomenclature{$E_{SOC}(t)$}{Error in state of charge at sample $t$}
\nomenclature{$E_{p}(t)$}{Difference between current and predicting network power at sample $t$, where $p(t) \in \textbf{p}$}
\nomenclature{$\hat{p}_{net}(t+\Delta t)$}{Predicted next network power at sample $t$}
\nomenclature{$\alpha$}{PID weight vector for compensator PID$_1$}
\nomenclature{$\beta$}{PID weight vector for compensator PID$_2$}
\nomenclature{$a$}{Weight vector for compensator input regression of the AR model}
\nomenclature{$b$}{Weight vector for compensator output regression of the AR model}
\nomenclature{$N$}{Number of regressors of the AR model}
\nomenclature{$p_1(t)$, $p_2(t)$}{Corrective BESS power components from PID$_1$ and PID$_2$, respectively}
\nomenclature{$SOC_{tol}$}{SOC tolerance, i.e. maximum deviation from the prescheduled SOC profile}

Inside the PID$_1$ component, a SOC error term, $E_{SOC}(t)$, is computed.
This term is the difference between the scheduled SOC profile, $SOC(t)$, and the actual (or simulated) SOC values, $SOC^*(t)$.
The following equation captures this error term.

\input{_chapter2/equ/soc-error}

Applying a standard, linearly weighted dynamic gain vector, $\alpha$, to the SOC error, allows the calculation of a corrective BESS power component dynamically.
Here, $\alpha = [\alpha_P, \alpha_I, \alpha_D]$, where being the P, I and D weights, respectively.
This corrective power is denoted as $p_1(t+\Delta t)$, and is defined as follows:

\input{_chapter2/equ/corrective-component-soc}

Here, the integral component removes steady-state error and the instantaneous error differential prevents overshooting.
All in all, this compensator uses present and past values to issue a corrective future BESS instruction.
Compensator PID$_2$ on the other hand uses values from the present, past and future in order to minimise the power transient and load peaks.

\input{_chapter2/fig/power-transient-minimisation}

Figure \ref{ch2:fig:power-transient-minimisation} summarises the time series computations for each power sample at times $t$, $t+\Delta t$, etc.
In theory, PID$_2$ would use present power readings, $p_{network}(t)$, and a power value of the immediate future, i.e. $p_{network}(t+\Delta t)$, to compute a power error signal, which is to be reduced to a smallest possible value.
This error signal is defined as:

\input{_chapter2/equ/power-error-signal}

However, since the future network power is unknown an ``estimated next power'', $\hat{p}_{network}(t+\Delta t)$, is used instead.
This value is the PID$_2$'s input from the MPC and results in an ``estimated power error signal'':

\input{_chapter2/equ/power-error-estimate}

Similarly to PID$_1$, PID$_2$ produces a correcive BESS power component, $p_2(t)$ that smoothens the resulting power profile.
This corrective BESS power is also computed using a standard linear weighted dynamic vectir $\beta$ (with $\beta = [\beta_P, \beta_P, \beta_P]$, being the P, I and D weight, respectively):

\input{_chapter2/equ/corrective-component-power}

Finally, the ``next BESS power'' can be deduced by adding the two corrective BESS power components, as shown in the equation below.

\input{_chapter2/equ/next-battery-power}

Both PID compensators do however depend on correctly chosen weights for $\alpha$ and $\beta$.
Therefore they need to be tuned prior to executing the dynamic control.
For this work a minimisation problem was formulated, based on a cost function, $\zeta^*(\alpha, \beta)$, to deduce the two weight vectors as follows:

\input{_chapter2/equ/cost-weights}

Here, $\zeta^*(\alpha, \beta)$ is defined as:

\input{_chapter2/equ/dynamic-cost}

In Equation \ref{ch2:equ:cost-weights} and \ref{ch2:equ:dynamic-cost}, $\zeta^*(\alpha, \beta)$ represents the minutely peak load during a day, when BESS schedules are adjusted with the corresponding $\alpha$ and $\beta$ weights.
Also, the same SOC tolerance that was used to generate the SOC schedule, i.e. $SOC_{tol}$, is included also to prevent the solution from deviating off the prescheduled SOC profile.
Additionally, this constraint assures solution convergence for the specific load case.
To generalise this solution for all cases, the minimisation problem was applied to several daily load profiles, resulting in several $\alpha$ and $\beta$ weights.
The most optimal values for $\alpha$ and $\beta$ that resulted in system convergence were extracted from this set of weights and used in the case studies.
All details concerning these case studies are outlined in Section \ref{ch2:sec:case-studies}.

\subsection{Model predictive control}

As explained in the literature, Model Predictive Control (MPC) is favoured over Set-Point Control (SPC), since it takes into account time-series to produce a behaviour.
With this knowledge, MPC can be used to not only react to recent changes but also to counteract foreseen trends.
Different approaches exist to obtain these foreseen trends and these approaches highly vary in accuracy, computational burden and robustness.
Equally, the characteristics of underlying data which is used to train these models impacts their performances.
For the presented work, an efficient and robust approach is required, since system deployment dictates these functional requirements.
As a result, prediction accuracy is an optional requirement, which becomes important only when the predicting model can issue predictions in real-time and does (for the predicting horizon) remain stationary and bounded.

The simplest form of producing a prediction, is to assume that the currently observed load will also apply in the future.
This kind of prediction does however not take into account model dynamics.
An AR model on the other hand, uses a series of past observations to predict the next.
Yet the further into the future these predictions are made, the less accurate they become.
Therefore, this work only attempts to issue a power prediction for the immediate future, i.e. next sample time at $t+\Delta t$.
Since external forces can and often do impact the behaviour of the model, the AR model is treated as an exogenous model, with a time-series of input powers, $p(t) \in \textbf{p}$, a time-series of predicted ``next powers'', $\hat{p}(t) \in \hat{\textbf{p}}$, and an internal delay function $z^{-1}$.

\input{_chapter2/fig/mpc-arx}

Figure \ref{ch2:fig:mpc-arx} graphically captures the standard AR model's function tree, which is also represented mathematically in the following equation:

\input{_chapter2/equ/mpc-arx}

Values of the two weight vectors $\textbf{a}$ and $\textbf{b}$, where $a_i \in \textbf{a}$ and $b_i \in \textbf{b}$, are determined during runtime using the standard least squares adaptive algorithm.
This algorithm dynamically adjusts $\textbf{a}$ and $\textbf{b}$ to minimise the prediction for each time-step.
Beside the correct values for $\textbf{a}$ and $\textbf{b}$, the model's number of regressors, $N$, is also predicted to impact the model's performance ($N$ is also referred to as the ``model length'').
The example in Figure \ref{ch2:fig:mpc-arx} represents a symmetric model where $N=3$.
This short length however is most likely insufficient in predicting $p(t+\Delta t)$, which is why several models of increasing lengths are assessed and compared.
From this comparison, the impact of $N$ on the models' resulting values of $\hat{p}(t+\Delta t)$, and correspondingly on the performance of the dynamic controller can be discussed.
Details about the cases for different model length are presented in the case studies in Section \ref{ch2:sec:case-studies}.










