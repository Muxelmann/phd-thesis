\section{Coordination of EV charging}
\label{ch3:sec:ev-coordination}

Here, an algorithm for EV charging is presented, which is later implemented in both a synchronised and desynchronised case.
Real load data is used in combination with EV demand to evaluate the performance of the algorithm at preventing new power spikes from occurring.
Convergence of the algorithm is studied and convergence criteria as well as rate of convergence are also presented.

This section is structured as follows.
First, the means and assumptions for calculating EV demand is defined.
Then the real load data is introduced and explained.
The EV scheduling algorithm is introduced next, before the performance parameters are presented.

\subsection{EV Demand}

EVs were modelled as loads that, over the course of a scheduling horizon, $H$, each need to consume a certain amount of energy, $E_u$, to simulate charging their batteries.
Each EV, i.e. $u$, is part of a fleet of charging and coordinated EVs, i.e. $u \in [1, \dots, U]$.
Unlike typical loads (e.g. households), EVs do not have a predetermined load profile in this simulation and are therefore flexible to schedule their demand, $p_{u,k}$, where $p_{u,k} \in \textbf{p}_u$.
In other words, they need to autonomously assign each charging plan over a certain number of future time-slots.
Due to limitations in on-board power electronics, each EV's maximum charge rate, $P_{max,u}$, is restricted and may not be exceeded.
Equally, in order to meet the EV's charging demand over the scheduling horizon, $H$, a soft minimum charging power, $P_{min,u}$ is also introduced:

\input{_chapter3/equ/power-charge-minimum}

Although the upper limit is hard, i.e. caused by technical restrictions, this lower limit is a necessity to initiate the scheduling procedure, which will become apparent when the scheduling algorithm is explained.
Using MAS, EVs utilise their broker agents to purchase energy quantities for each time-slot, $k$, and also sell or ``undo'' some of the already acquired energy quantities if it contributed towards a new load spike.

\subsection{Base Load}

To represent real power consumption in simulations, historic customer load profiles were used in this work \cite{IrishData2002}.
This dataset consisted of 7392 demand readings for 543 loads, which were sampled at half-hourly period, i.e. $\kappa = 0.5$ hours.
A single scheduling horizon was defined as one day, therefore $H=48$ samples.

In this context, each household, i.e. physical entity, dispatches its broker agents to order the household's daily energy demand; therefore it a scenario with some foresight is assumed.
After having issued this energy request, the entire network demand is known to the supplier and can be relayed to all broker agents when they query for it.
This ability is exploited when scheduling and negotiating the unknown EV charging profiles.
More specifically, all households' broker agents communicate with the suppler's broker agents to optimally embed their charging profiles, $p_u(k)$, within this aggregated base load, $d(k)$.

\subsection{Scheduling Algorithm}

For the EV charging coordination strategy, an algorithm was designed that generates optimised charging profiles for each EV.
Here, optimality implies that when adding all aggregated charging profiles to the network's base demand, $d(k)$, no additional additional spikes occur in the resulting demand profile, $p(k)$.
These profiles were generated by repetitively querying for the network's base load, adjusting individual EV charging profiles, and resubmitting the adjusted charging profile.
As already stated, the common assumption when designing such a scheduling algorithm is that all scheduling entities are synchronised, i.e. wait for each other, before querying for the network's base load.
For visualisation, the message exchange bewteen two loads and a supplier including a synchronisation time are shown in Figure \ref{ch3:fig:agent-synchronisation}.

\input{_chapter3/fig/agent-synchronisation}

Here, the horizontal arrows indicate messages being sent from loads (i.e. EV agents) to a supplier and vertical lines indicate processing or idle time.
In this figure, a single iteration is shown, which can be broken into several sub-processes of querying, scheduling, updating and synchronising.
From top to bottom, the temporal execution of these sub-processes is as follows:
First, both load$_1$ and load$_2$ query the supplier for the currently known network load (i.e. query($l_1$) and query($l_2$)).
This network load is used to schedule their power profiles to ``fill valleys'', i.e. only charge their EVs during periods of low demand.
Upon receipt of a  reply from the energy supplier (i.e. reply($l_1$) and reply($l_2$)), both loads immediately start scheduling these profiles.
As shown in the example, load$_1$ found a solution before load$_2$ and can therefore inform the supplier about its intended load profile sooner, by sending an update (i.e. update$(l_1)$) to the supplier.
Subsequently querying the supplier for an updated network load would be premature, since other loads (i.e. load$_2$) has not yet generated and updated its load profile.
Therefore, a synchronisation mechanism has to be used, forcing load$_1$ to wait until all loads have sent updates to the supplier.
In this example, load$_1$ waits until load$_2$ has send an updated and the corresponding profile was acknowledged by the supplier (i.e. ack$(l_2)$).
Only thereafter, a synchronisation event may be triggered (i.e. \textit{SYNC} event).
After this synchronisation event, the next algorithm iteration is initiated and the procedure repeats.
Here, the second iteration's two querying messages are shown in the example.

%It is worth mentioning that this synchronisation is removed by purposefully desynchronising agents, and the impact of this desynchronisation on the algorithm is studied.
%However, the common algorithm design approach, where the presupposition that all loads will have successfully transmitted their charging profiles to the substation before the algorithm continues, is used in the design of the following algorithm.

\hl{Rewriting the entire algorithm explanation... The paper is very unclear!}

With this synchronised message and information exchange, the underlying algorithm that is

As shown in Figure \ref{ch3:fig:agent-synchronisation}, the proposed scheduling algorithm consists of four fundamental steps that are repeated for iteration of the algorithm.
These steps are to:

\begin{enumerate}
	\item query for the base network load,
	\item schedule the EV's charging according to load,
	\item update the supplier, and
	\item synchronise by waiting to let other EV's submit their schedules.
\end{enumerate}

During the first iteration of the algorithm (i.e. $n=1$), the EV demand is spread out over the load profile to only ``\textit{fill the lowest valley}''.
This process is shown in the following algorithm:

\input{_chapter3/alg/valley-filling}

If every EV does this, the aggregated EV demand may overfill this valley, which leads to all EVs having to undo some of the schedule.
Therefore, during any subsequent algorithm iteration (i.e. $n>1$), a portion of the previous EV schedule is undone, and reallocated in using an updated base demand profile.
The amount of ``\textit{undoing}'' is governed by the parameter $\alpha$, where $\alpha \in [0, 1)$).
When the value of $\alpha$ is chosen close to zero, then the corrections to the preceding schedules are very small.
Conversely, when the value of $\alpha$ is chosen close to one, then the corrections nearly undo all of the previously found charging profile.
To prevent the algorithm from allocating its entire charging power to a single time slot, a second parameter, $\beta$, is used, where $\beta \in [0, 1)$, too.
When the value of $\beta$ is chosen close to zero, then only a smaller fraction of power can be added to a time-slot of the charging profile.
And conversely, when the value of $\beta$ is chosen closer to one, the the charging power can be adjusted more aggressively.



In order to control the algorithm, two parameters are used, i.e. $\alpha$ and $\beta$.
Here, $\alpha \in (0, 1]$ and $\beta \in (0, 1]$, too.
These two parameters control the convergence rate of the algorithm, as well as its resultant steady-state ripple.
Since the algorithm is designed to update each EV's charging profile based on a preceding state (i.e. $n-1$), the algorithm's initialisation is explained before expanding on the updating procedure.

\subsubsection{Algorithm Initialisation ($n=1$)}

Having obtained the network's base demand profile (following the procedure mentioned above), the initial charging profile for each EV can be defined:

\input{_chapter3/equ/initial-charging-profile}












