\section{Coordination of EV charging}
\label{ch3:sec:ev-coordination}

In this section, an algorithm for EV charging is presented, which is later implemented in both a synchronised and desynchronised case.
Real load data is used in combination with EV demand to evaluate the performance of the algorithm at preventing new power spikes from occurring.
Convergence of the algorithm is studied and convergence criteria as well as rate of convergence are presented, too.

The structure of this section is as follows.
First, the means and assumptions for calculating EV demand is defined.
Then the real load data is introduced and explained.
The EV scheduling algorithm is introduced next, before the performance parameters are presented.

\subsection{EV Demand}

\nomenclature[K]{$T_\text{sch}$}{Scheduling horizon for EV charging, where $T_\text{sch} \in \mathbb{Z}^{>0}$ (Chapter \ref{ch3})}
\nomenclature[K]{$u$}{EV unit number, where $u \in [1, \dots, U]$ (Chapter \ref{ch3})}
\nomenclature[K]{$n$}{Iteration number of EV scheduling algorithm, where $N \in [1, \dots, N]$ (Chapter \ref{ch3})}
\nomenclature[K]{$U$}{Number of EVs that need to be scheduled, where $U \in \mathbb{Z}^{>0}$ (Chapter \ref{ch3})}
\nomenclature[K]{$N$}{Number of algorithm iterations to schedule multiple EVs, where $N \in \mathbb{Z}^{>0}$ (Chapter \ref{ch3})}
\nomenclature[K]{$p_{\text{EV},u,n}(t)$}{Scheduled EV charging power, for EV $u$ at algorithm iteration $n$ for time $t$, where $p_{\text{EV},u,n}(t) \in \mathbb{R}^{\geq 0}$ (Chapter \ref{ch3})}
\nomenclature[K]{$\textbf{p}_{\text{EV}, u, n}$}{Scheduled EV charging power vector, for EV $u$ at algorithm iteration $n$, where $p_{\text{EV},u,n}(t) \in \textbf{p}_{\text{EV},u,n}$ (Chapter \ref{ch3})}

\nomenclature[K]{$P_{\text{min},u}$}{Minimum EV charging power (Chapter \ref{ch3})}
\nomenclature[K]{$P_{\text{min},u}$}{Maximum EV charging power (Chapter \ref{ch3})}

EVs were modelled as loads that, over the course of a scheduling horizon, $T_\text{sch}$, each need to consume a certain amount of energy, $E_u$, to simulate charging their batteries.
Each EV, i.e. $u$, is part of a fleet of charging and coordinated EVs, i.e. $u \in [1, \dots, U]$.
Unlike typical loads (e.g. households), EVs do not have a predetermined load profile in this simulation and are therefore flexible to schedule their demand at each time $t$ a $p_{u,n}(t)$, where $p_{u,n}(t) \in \textbf{p}_{\text{EV},u,n}$.
In other words, they can autonomously assign their own charging plan over the predetermined number of future time-slots, $T_\text{sch}$.
Due to limitations in on-board power electronics, each EV's maximum charge rate, $P_{\text{max},u}$, is restricted and may not be exceeded.
Equally, in order to meet the EV's charging demand over the scheduling horizon, $T_\text{sch}$, a soft minimum charging power, $P_{\text{min},u}$ is also introduced:

\input{_chapter3/equ/power-charge-minimum}

Although the upper limit is hard, i.e. caused by technical restrictions, this lower limit is a necessity to initiate the scheduling procedure, which will become apparent when the scheduling algorithm is explained.
Using MAS, EVs utilise their broker agents to purchase energy quantities for each time-slot, $t$, and also sell or ``undo'' some of the already acquired energy quantities if it contributed towards a new load spike.

\subsection{Base Load}

\nomenclature[K]{$\Delta t$}{Sample period for EV scheduling, where $\Delta t \in \mathbb{R}^{>0}$ (Chapter \ref{ch3})}

To represent real power consumption in simulations, historic customer load profiles were used in this work \cite{IrishData2002}.
This dataset consisted of 7392 demand readings for 543 loads, which were sampled at half-hourly period, i.e. $\Delta t = 0.5$ hours.
A single scheduling horizon was defined as one day, therefore $T_\text{sch}=48$ samples.

In this context, each household, i.e. physical entity, dispatches its broker agents to order the household's daily energy demand; therefore it a scenario with some foresight is assumed.
After having issued this energy request, the entire network demand is known to the supplier and can be relayed to all broker agents when they query for it.
This ability is exploited when scheduling and negotiating the unknown EV charging profiles.
More specifically, all households' broker agents communicate with the suppler's broker agents to optimally embed their charging profiles, $p_{\text{EV},u,n}(t)$, within this aggregated base load.

\subsection{Scheduling Algorithm}

For the EV charging coordination strategy, an algorithm was designed that generates optimised charging profiles for each EV.
Here, optimality implies that when adding all aggregated charging profiles to the network's base demand, $p_\text{base}(t)$, no additional spikes occur in the resulting demand profile, i.e. $p_\text{base}(t) + \sum_{u=1}^U p_{EV,u,N}(t)$.
These profiles were generated by repetitively querying for the network's base load, adjusting individual EV charging profiles, and resubmitting the adjusted charging profile.
As already stated, the common assumption when designing such a scheduling algorithm is that all scheduling entities are synchronised, i.e. wait for each other, before querying for the network's base load.
For visualisation, the message exchange bewteen two loads and a supplier including a synchronisation time is shown in Figure \ref{ch3:fig:agent-synchronisation}.

\input{_chapter3/fig/agent-synchronisation}

In this figure, the horizontal arrows indicate messages being sent from loads (i.e. EV agents) to a supplier and vertical lines indicate processing or idle time.
Shown within Figure \ref{ch3:fig:agent-synchronisation} is a single scheduling iteration, which can be broken into the sub-processes of: querying, scheduling, updating and synchronising.
From top to bottom, the sequential execution of these sub-processes is as follows:

First, both load$_1$ and load$_2$ query the supplier for the currently known network load (i.e. query($l_1$) and query($l_2$)).
This network load is used to schedule their power profiles to ``fill valleys'', i.e. only charge EVs during periods of low demand.
Upon receipt of a reply from the energy supplier (i.e. reply($l_1$) and reply($l_2$)), both loads immediately start scheduling their profiles.
In the example above, load$_1$ found a solution before load$_2$ and can therefore inform the supplier about its intended load profile sooner, by sending an update (i.e. update$(l_1)$) to the supplier.
Subsequently querying the supplier for an updated network load would be premature, since the other load (i.e. load$_2$) has not yet generated and updated its load profile.
Therefore, a synchronisation mechanism had to be used, forcing load$_1$ to wait until all loads have sent updates to the supplier.
Here, load$_1$ waits until load$_2$ has sent an update and the corresponding profile was acknowledged by the supplier (i.e. ack$(l_2)$).
Only after this had happened, a synchronisation event would be triggered (i.e. \textit{SYNC} event).
After this synchronisation event, the next algorithm iteration is initiated and the procedure repeats.
Since all subsequent iterations are similar to the one shown in Figure \ref{ch3:fig:agent-synchronisation}, only the two querying messages of the  second iteration are shown.

Although the timing and message exchange has been defined, the mechanism to allocate and reallocate charging powers in order to achieve a valley filling behaviour has not yet been defined.
This behaviour is shown in Figure \ref{ch3:fig:valley-filling}, where several iterations numbered $n$ are shown, and for each subsequent iteration, some amount of prescheduled power is reallocated to different time-slots.

\input{_chapter3/fig/valley-filling}

For every iteration in Figure \ref{ch3:fig:valley-filling}, charging profiles are added onto a base network load, $\textbf{p}_{base,n}$, where $p_{base,n}(t) \in \textbf{p}_{base,n}$.
This base load is shown as the bold black line and does not change throughout EV scheduling.
During the first iteration, i.e. Figure \ref{ch3:subfig:valley-filling-1} where $n=1$, the charging profile during iteartion $n$ of EV $u$ is $\textbf{p}_n$ (where $p_{u,n}(t) \in \textbf{p}_n$), and it is determined by assigning the EV charging power to the time-slots of lowest load, until the total EV energy demand is met.
Since all EVs schedule their profiles based on the same knowledge of $\textbf{p}_{base,n}$, the aggregated charging power generates a new spike.
This spike would be seen on the updated or temporary demand profile, $\hat{\textbf{p}}_{base, n}$, where $\hat{p}_{base, n}(t) \in \hat{\textbf{p}}_{base, n}$ is defined as:

\input{_chapter3/equ/updated-demand-profile}

For the next iteration $n+1$, i.e. Figure \ref{ch3:subfig:valley-filling-2} where $n=2$, a proportion of the previously scheduled power vector $\textbf{p}_{n-1}$ is ``undone'' and reallocated onto the new trough in temporary demand.
Subsequently, the spike in the resulting $\hat{\textbf{p}}_{base, n}$ is therefore reduced and reallocated to different periods.
The amount of power that is undone for each time-slot is determined by the ``\textit{undoing}'' parameter $\alpha$, where $\alpha \in [0, 1)$.


\hl{Continue here...}

\hl{Rewriting the entire algorithm explanation... The paper is very unclear!}

During the first iteration, i.e. Figure \ref{ch3:subfig:valley-filling-1} where i.e. $n=1$, a base network load, $\textbf{p}_{base}(n)$ (black line) indicates the underlying and unmodifiable load that is expected to occur.
Following the same annotation that was used in previous chapters, $k$ represents a half-hourly time-slot (i.e. sample period $\kappa = 30\text{minutes}$), so that each power value $p_{base,k}(n) \in \textbf{p}_{base}(n)$.
Here, $n$ represents the iteration number, where $n \in [1, \dots, N]$.
An EV charging power $p_{u,k}(n)$ (green line) is added to the time where demand is lowest.
The addition of this charging power is assigned for each EV, $u$, at time $k$, during the iteration step $n$, and for convenience this adding process is highlighted in green, too.
Therefore, each EV's charging profile consists of several charge power values, where $p_{u,k}(n) \in \textbf{p}_u(n)$.


During subsequent iterations, i.e. $n>1$, a proportion of the applied charging power, which potentially contributed to a new demand peak, is subtracted and added to new demand troughs.
The magnitude of the reduction is determined by an ``\textit{undoing}'' parameter, $\alpha$, where $\alpha \in [0, 1)$.
As seen in the above figure, the undone energy is highlighted in red and the corresponding addition of unassigned charge demand is, again, highlighted in green (an arrow emphasises the direction of reallocation).
\hl{Here, it is important to note that for all steps where power is added to the the EV's charging profile, none of the values must exceed the EV's maximum charging power, }$P_{\text{max},u}$.
In fact, in order to spread out the added powers over multiple periods of low demand, a second so called ``\textit{spreading}'' parameter is used, $\beta$, where $\beta \in [0, 1)$.
Therefore, the subsequent equation that determines charge power allocation for each iteration of the scheduling algorithm is defined as follows:

\input{_chapter3/equ/valley-filling-equation}

An intermediate demanded energy, $\hat{E}_u(n)$, is defined, which captures the total energy that needs to be allocated in the charge profile.
In the first iteration, this energy is equal to the total, actual EV energy demand, $E_u$, and for all subsequent iterations, this energy is equal to the undone energy, i.e.:

\input{_chapter3/equ/intermediate-demand-energy}

Since the energy that is charged by the resulting charging profile has to equate to the original charging demand, Equation \ref{ch3:equ:intermediate-demand-energy} can be expanded into a recursive formula:

\input{_chapter3/equ/intermediate-demand-energy-expanded}

Instead of being based on the general energy demand, this form shows how the algorithm's power reduction mechanism acts on the previous iteration's power profile.
Therefore, the undone power portion can be defined as:

\input{_chapter3/equ/undone-power}

To summarise: the message exchange is explained in Figure \ref{ch3:fig:agent-synchronisation}; the power allocation captured to achieve valley filling is explained in Equation \ref{ch3:equ:valley-filling-equation}; and the recursive intermediate demand is defined in Equation \ref{ch3:equ:intermediate-demand-energy-expanded}.
When combined, the complete smart valley filling algorithm can be defined as shown in Algorithm \ref{ch3:alg:valley-filling}.

\input{_chapter3/alg/valley-filling}













